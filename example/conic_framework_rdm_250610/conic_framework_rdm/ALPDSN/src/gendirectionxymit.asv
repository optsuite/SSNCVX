
  
function [dx,dy,trans]= gendirectionxy(Ftz,K,At,trans,cgopts, method)
if nargin < 6
    method = 'iterative';
end
m = size(At{1}, 2);
Amap  = trans.Amap;
ATmap = trans.ATmap;
sig = trans.sigma; %注意这里与SSNSDP的不同之处
tau1 = trans.NEWT.tau1;
tau2 = trans.NEWT.tau2;
CG_maxit = cgopts.CG_maxit;
pcgTol = cgopts.CG_tol;
Lchol = trans.Lchol;
Fx = Ftz.FX;
Fy = Ftz.FY;
rhsx = -Fx;
rhsy = -Fy;
%Ftz.par: \Sigma

% D = Ftz.par;

% Dtau2 = ProjJac_ops(D, K, 'affine', - 1 / sig, 1 / sig + tau2); % D^{\tau_2}

% invDtau2 = ProjJac_ops(Dtau2, K, 'affine_inv', 1 , 0); % (D^{\tau_2})^{-1}


tmptau = ( 1 + sig*tau2 );


% check Dtau2 * invDtau2 = I

% r = rhsx ;
% r1 = DPhi(K, Dtau2, r);
% r2 = - 1 / sig * (DPhi(K, D, r) + tmptau * r);
% norm(r1 - r2)
% norm(DPhi(K, invDtau2, r1))
% norm(DPhi(K, invDtau2, r1) - r)

% D * (D^{\tau_2})^{-1} = - sig * I -  sig * (1+ sig*tau_2) * (D + (1 + sig*tau_2) * I)^{-1}
% tmpinvD = ProjJac_ops(D, K, 'affine_inv', 1, tmptau); % tmpinvD = (D + (1 + sig*tau_2) * I)^{-1}
% DinvDtau2 = ProjJac_ops(tmpinvD, K, 'affine', sig * tmptau, - sig);


% iHW = DinvDtau2;

% original code 

% for p =1: length(K)
%     cone = K{p};
%     if strcmp(cone.type, 's')
%         iHW.Dsch2{p} = sig * D.Dsch2{p} ./ (1 + sig * tau2 - D.Dsch2{p}); %iHW: \tilde{\Sigma} 
%         iHW.Dsch2t{p} = iHW.Dsch2{p}';
%         iHW.Dsch1{p} = 1 / tau2 ;
%     elseif strcmp(cone.type, 'q')
%         iHW.Dsch1{p} = zeros(size(D.Dsch1{p}));
%         iHW.Dsch2{p} = zeros(size(D.Dsch2{p}));
%         iHW.shift{p} = zeros(size(D.shift{p}));
%         idx1 = (D.dd{p}(:, 2) > 0);   % both eigenvalues are positive
%         idx2 = (D.dd{p}(:, 1) >= 0 & D.dd{p}(:, 2) <= 0); % one eigenvalue is positive
%         idx3 = (D.dd{p}(:, 1) < 0); % both eigenvalues are negative
%         iHW.Dsch1{p}(idx1) = 0;
%         iHW.Dsch2{p}(idx1) = 0;
%         iHW.shift{p}(idx1) = 1 / tau2;
%         iHW.Dsch1{p}(idx2) = - sig * tmptau ./ (D.shift{p}(idx2) + tmptau) .* (D.Dsch1{p}(idx2) ./ (D.Dsch1{p}(idx2) + D.shift{p}(idx2) + tmptau) );
%         iHW.Dsch2{p}(idx2) = - sig * tmptau ./ (D.shift{p}(idx2) + tmptau) .* (D.Dsch2{p}(idx2) ./ (D.Dsch2{p}(idx2) + D.shift{p}(idx2) + tmptau) );
%         iHW.shift{p}(idx2) = - sig * D.shift{p}(idx2) ./ ( D.shift{p}(idx2) + tmptau) ;
%         iHW.Dsch1{p}(idx3) = 0;
%         iHW.Dsch2{p}(idx3) = 0;
%         iHW.shift{p}(idx3) = 0;
%     elseif strcmp(cone.type, 'l') || strcmp(cone.type, 'u')
%         iHW.Dsch2{p} = sig * D.Dsch2{p} ./ (1 + sig * tau2 - D.Dsch2{p});
%         iHW.Dsch2t{p} = iHW.Dsch2{p}';
%     end
% end

iHW = Ftz.par;

for k = 1:length(iHWy.Dsch12)
    iHW.Dsch2{k} = (sig*iHW.Dsch2{k})./(1+tau2*sig-iHW.Dsch2{k});
    iHW.Dsch2t{k} = iHW.Dsch2{k}';
    iHW.Dsch1{k} = 1/tau2;
end
N24rhsx = DPhimit(K, iHW, rhsx);
N24rhsx = Amap(N24rhsx);             %N_2(N_4)^{-1} Fx 
rhs1 = rhsy - N24rhsx;

% iHWy = D * Dtau2^{-1} * D + sig * D = sig * tmptau * I - sig * tmptau^2 * (D + tmptau * I)^{-1};
% invDtmptau = ProjJac_ops(D, K, 'affine_inv', 1, tmptau); % (D + tmptau * I)^{-1}
% iHWy = ProjJac_ops(invDtmptau, K, 'affine', -sig*tmptau^2, sig*tmptau);
% 
% iHWy.sig = 1;
% iHWy.epsilon = tau1;

iHWy = Ftz.par;
iHWy.sig = 1;
for k = 1:length(iHWy.Dsch12)
    iHWy.Dsch12{k} = (iHWy.Dsch2{k}.*(1+sig*tau2)*sig)./(1+sig*tau2-iHWy.Dsch2{k});
    iHWy.Dsch12t{k} = iHWy.Dsch2{k}';
    iHWy.Dsch1{k} = (1+sig*tau2)/tau2;
end

iHWy.epsilon = tau1;
iHWy.K = K;

L = struct();
% L.invdiagM = trans.invdiagM;
if strcmp(method, 'iterative')
%     [dy,relres,flag] = psqmr(@matvec_y, K, At, rhs1, iHWy, L, pcgTol, CG_maxit, Lchol);
% [dy,relres,flag] = psqmr(@matvec_sdpnaly, K, At, rhs1, iHWy, L, pcgTol, CG_maxit, Lchol);
% [dy,relres,flag] = psqmr2(@matvec_sdpnaly,blk,At,rhs1,iHWy.Dsch1{1},iHWy,L,pcgTol,CG_maxit,Lchol);
% [dy,relres,flag] = psqmr_sdpnal2(@matvec_sdpnaly,trans.blk,At,rhs1,iHWy.Dsch1{1},iHWy,L,pcgTol,CG_maxit,Lchol);
[dy,relres,flag] = psqmr2(@matvec_y2mit,K,At,rhs1,iHWy,L,pcgTol,CG_maxit,Lchol);
%     [dy,relres,flag] = psqmr(@matvec_y,K,At,rhs1,iHWy,L,pcgTol,CG_maxit,Lchol);
    1;
trans.cgres = relres;
elseif strcmp(method, 'direct')
    %%
    %% use direct method to solve linear system
    % lhs* dy = rhs1
    % lhs = iHWy.sig * Rt^{-1} * S * A * iHWy.Dsch * At * Sinv * R^{-1} + epsilon * I
    % Sinv * y is equivalent to y(perm) = y
    % S * y is equivalent to y = y(perm)
    % lhs * dy = rhs is equivalent to 
    % (iHWy.sig  * A * iHWy.Dsch * At  + epsilon * Sinv * Rt * R * S) * (Sinv * R^{-1} * dy) = Sinv * Rt * rhs

    % compute RtR = Sinv * Rt * R * S 
%     if ~isfield(Lchol, 'RtR')
%         Lchol.RtR = Lchol.Rt * Lchol.R;
%         Lchol.RtR(Lchol.perm, Lchol.perm) = Lchol.RtR;
%         % Rperm = Lchol.R(:, Lchol.perm);
%         % Lchol.RtR = Rperm' * Rperm;
%     end
[dy,relres,flag] = cholssncp(K,At,rhs1,iHWy,L,pcgTol,Lchol);
    % compute lhs = iHWy.sig * A * iHWy.Dsch * At  + epsilon * Sinv * Rt * R * S
%     par = iHWy;
%     AHAt = linsysinit(At, 'sparse');
%     for p =1: length(K)
%         cone = K{p};
%         if strcmp(cone.type, 's')
% 
%         elseif strcmp(cone.type, 'q')
%             if (~isempty(par.Dsch2{p}))
%                 H = struct;
%                 H.diag = repelem(par.shift{p}, cone.size, 1);  
%                 H.lr = [blk_spdiag(par.P1{p}, cone.size), blk_spdiag(par.P2{p}, cone.size)];
%                 H.coeff = [par.Dsch1{p}; par.Dsch2{p}];
%                 AHAt = linsysconstruct_cone_q(AHAt, cone.size, At{p}, H, 'sparse') ;
%             end    
%         elseif strcmp(cone.type, 'l')
%             if (~isempty(par.Dsch2{p}))
%                 AHAt.mat11 = AHAt.mat11 + At{p}' * spdiag(par.Dsch2{p}) * At{p};
%                 %AorgDAt = AorgDAt + trans.Atorg{p}' * spdiag(par.Dsch2{p}) * trans.Atorg{p};
%             end
%         elseif strcmp(cone.type, 'u')
%         
%         end
%     end
% 
%     AHAt.mat11 = par.sig * AHAt.mat11;
%     AHAt.mat11 = AHAt.mat11 + par.epsilon * Lchol.RtR;
%     AHAt = linsysconcat(AHAt, 'sparse');
%     
%     % compute rhs1_temp = Sinv * Rt * rhs1
%     rhs1_temp = zeros(size(rhs1));
%     rhs1_temp(Lchol.perm) = Lchol.Rt * rhs1;
% 
%     rhs1_temp = [rhs1_temp; zeros(AHAt.dim2 + AHAt.dim3, 1)];
% 
%     % solve lhs * ( Sinv * R^{-1} * dy) = rhs
%     dy = AHAt.mat \ rhs1_temp;
%     dy = dy(1: AHAt.dim1) ;
% 
%     % print dim1, dim2, dim3
%     % fprintf("dim1: %d, dim2: %d, dim3: %d", AHAt.dim1, AHAt.dim2, AHAt.dim3);
% 
%     % recover dy 
%     dy = Lchol.R * dy(Lchol.perm);

    % check residual
    relres = norm(rhs1 - matvec_y2(K, At, iHWy, dy, Lchol) ) / (1 + norm(rhs1));
    trans.cgres = [relres relres];
    % fprintf("resdue of computing dy: %e\n", relres);
%     flag = 1;
end


%%


trans.flag = flag;
trans.cgiter = length(relres);

rhs2 = ATmap(dy);
rhs2 = DPhimit(K, Ftz.par, rhs2);

rhs2 = rhs2 + rhsx ;
rhs2 = rhs2 / tmptau;
% iHWx = ProjJac_ops(D, K, 'affine_inv', - 1 / (sig * tmptau), - 1 / sig); % - (tmptau * D^{\tau_2})^{-1}

% dx= DPhimit(K, iHWx, rhs2) ;

iHWx = Ftz.par;
for k = 1:length(iHWy.Dsch12)
    iHWx.Dsch2{k} = (iHWx.Dsch2{k}*sig)./(1+sig*tau2-iHWx.Dsch2{k});
    iHWx.Dsch2t{k} = iHWx.Dsch2{k}';
    iHWx.Dsch1{k} = 1/tau2;
end
%     dx= DPhi_sdpnalN4T(blk,iHWx,rhs2,sig,tau);
dx= DPhimit(K,iHWx,rhs2);
for k = 1:length(iHWy.Dsch12)
    dx{k} = dx{k} + sig * rhs2{k};
end

% for k = 1:trans.nblock
%     dx{k} = dx{k} + sig * rhs2{k};
% end
% % original code
% rhs2 = rhs2 - Fx ;
% rhs2 = rhs2 / (1 + sig * tau2);
% % iHWx: T
% iHWx = D;
% for p =1: length(K)
%     cone = K{p};
%     if strcmp(cone.type, 's')
%         iHWx.Dsch2{p} = (sig * D.Dsch2{p} )./ (1 + sig * tau2 - D.Dsch2{p} );
%         iHWx.Dsch1{p} = 1 / tau2;
%         iHWx.shift{p} = sig;
%     end
% end
% dx_= DPhi(K, iHWx, rhs2);

% norm(dx - dx_);



%% check residual of newton system wrt [dx; dy]
D_lmut = @(x) DPhimit(K, Ftz.par, x);
Atdy = ATmap(dy);
N1dy = sig * Amap(D_lmut(Atdy)) + tau1 * dy;
N2dx = Amap(DPhimit(K, Ftz.par, dx));
N3dy = - D_lmut(Atdy) ;
N4dx = (1 / sig + tau2) * dx - 1 / sig * D_lmut(dx);
resy = N1dy + N2dx - rhsy;
resx = N3dy + N4dx - rhsx;
trans.newton_res = sqrt(norm(resy) ^ 2 + norm(resx) ^ 2) / (1 + sqrt(norm(rhsy) ^ 2 + norm(rhsx) ^ 2)) ;
% 
% 
% trans.newton_res = -1;


end
